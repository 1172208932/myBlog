<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>node | Robozy的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://img0.baidu.com/it/u=3041595518,152570800&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="Just Text">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.ee4a6f20.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.135fd291.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.2b6e9a37.js" as="script"><link rel="preload" href="/myBlog/assets/js/20.a06b9bd2.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.73d6db4f.js"><link rel="prefetch" href="/myBlog/assets/js/11.83f7c59d.js"><link rel="prefetch" href="/myBlog/assets/js/12.e91659dd.js"><link rel="prefetch" href="/myBlog/assets/js/13.b5d51fe6.js"><link rel="prefetch" href="/myBlog/assets/js/14.aa0247bc.js"><link rel="prefetch" href="/myBlog/assets/js/15.c239c198.js"><link rel="prefetch" href="/myBlog/assets/js/16.8413d1dc.js"><link rel="prefetch" href="/myBlog/assets/js/17.1ea8782c.js"><link rel="prefetch" href="/myBlog/assets/js/18.30072871.js"><link rel="prefetch" href="/myBlog/assets/js/19.d622314c.js"><link rel="prefetch" href="/myBlog/assets/js/21.89d0532d.js"><link rel="prefetch" href="/myBlog/assets/js/22.cc603dc5.js"><link rel="prefetch" href="/myBlog/assets/js/23.10f9be88.js"><link rel="prefetch" href="/myBlog/assets/js/24.1ec62645.js"><link rel="prefetch" href="/myBlog/assets/js/25.6afabc05.js"><link rel="prefetch" href="/myBlog/assets/js/3.f70d730b.js"><link rel="prefetch" href="/myBlog/assets/js/4.8c29605e.js"><link rel="prefetch" href="/myBlog/assets/js/5.a8db63f7.js"><link rel="prefetch" href="/myBlog/assets/js/6.8bf4fa59.js"><link rel="prefetch" href="/myBlog/assets/js/7.2e7f0ae4.js"><link rel="prefetch" href="/myBlog/assets/js/8.d8467b84.js"><link rel="prefetch" href="/myBlog/assets/js/9.2e9fa621.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.ee4a6f20.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><img src="https://img0.baidu.com/it/u=3041595518,152570800&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" alt="Robozy的博客" class="logo"> <span class="site-name can-hide">Robozy的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/myBlog/demos/" class="nav-link">
  DEMO
</a></div><div class="nav-item"><a href="/myBlog/web/" class="nav-link router-link-active">
  WEB
</a></div><div class="nav-item"><a href="/myBlog/game/" class="nav-link">
  GAME
</a></div><div class="nav-item"><a href="https://github.com/1172208932" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/myBlog/demos/" class="nav-link">
  DEMO
</a></div><div class="nav-item"><a href="/myBlog/web/" class="nav-link router-link-active">
  WEB
</a></div><div class="nav-item"><a href="/myBlog/game/" class="nav-link">
  GAME
</a></div><div class="nav-item"><a href="https://github.com/1172208932" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/myBlog/web/PromiseA+规范.html" class="sidebar-link">PromiseA+规范</a></li><li><a href="/myBlog/web/generator &amp; async await.html" class="sidebar-link">Generator 和 Async 简介</a></li><li><a href="/myBlog/web/实现一个Promise.html" class="sidebar-link">一步步实现一个Promise</a></li><li><a href="/myBlog/web/ts相关.html" class="sidebar-link">ts相关</a></li><li><a href="/myBlog/web/es6.html" class="sidebar-link">es6</a></li><li><a href="/myBlog/web/面向对象.html" class="sidebar-link">面向对象</a></li><li><a href="/myBlog/web/this.html" class="sidebar-link">this</a></li><li><a href="/myBlog/web/node.html" aria-current="page" class="active sidebar-link">node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/web/node.html#全局对象解析" class="sidebar-link">全局对象解析</a></li><li class="sidebar-sub-header"><a href="/myBlog/web/node.html#node-js-事件循环模型" class="sidebar-link">node.js 事件循环模型</a></li></ul></li><li><a href="/myBlog/web/网络.html" class="sidebar-link">网络</a></li><li><a href="/myBlog/web/Vuecli.html" class="sidebar-link">vue-cli</a></li><li><a href="/myBlog/web/VueRouter.html" class="sidebar-link">VueRouter</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="node"><a href="#node" class="header-anchor">#</a> node</h1> <h2 id="全局对象解析"><a href="#全局对象解析" class="header-anchor">#</a> 全局对象解析</h2> <p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p> <p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p> <p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p> <h3 id="全局对象和全局变量"><a href="#全局对象和全局变量" class="header-anchor">#</a> 全局对象和全局变量</h3> <p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p> <p>在最外层定义的变量；
全局对象的属性；
隐式定义的变量（未定义直接赋值的变量）。
当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p> <p>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p> <h3 id="filename"><a href="#filename" class="header-anchor">#</a> __filename</h3> <p>__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> __filename <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="dirname"><a href="#dirname" class="header-anchor">#</a> __dirname</h3> <p>__dirname 表示当前执行脚本所在的目录。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> __dirname <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="settimeout-cb-ms"><a href="#settimeout-cb-ms" class="header-anchor">#</a> setTimeout(cb, ms)</h3> <p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p> <p>返回一个代表定时器的句柄值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">printHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 两秒后执行以上函数</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>printHello<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="cleartimeout"><a href="#cleartimeout" class="header-anchor">#</a> clearTimeout</h3> <h3 id="setinterval"><a href="#setinterval" class="header-anchor">#</a> setInterval</h3> <h3 id="clearinterval"><a href="#clearinterval" class="header-anchor">#</a> clearInterval</h3> <h3 id="console"><a href="#console" class="header-anchor">#</a> console</h3> <h3 id="process"><a href="#process" class="header-anchor">#</a> process</h3> <p>process 是一个全局变量，即 global 对象的属性。</p> <p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p> <ol><li><p>exit
当进程准备退出时触发。</p></li> <li><p>beforeExit
当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</p></li> <li><p>uncaughtException
当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</p></li> <li><p>Signal 事件
当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">code</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 以下代码永远不会执行</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;该代码不会执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'退出码为:'</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;程序执行结束&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="退出的状态码"><a href="#退出的状态码" class="header-anchor">#</a> 退出的状态码</h3> <ol><li>Uncaught Fatal Exception
有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</li></ol> <p>3	Internal JavaScript Parse Error
JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</p> <p>4	Internal JavaScript Evaluation Failure
JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</p> <p>5	Fatal Error
V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</p> <p>6	Non-function Internal Exception Handler
未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</p> <p>7	Internal Exception Handler Run-Time Failure
未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</p> <p>9	Invalid Argument
可能是给了未知的参数，或者给的参数没有值。</p> <p>10	Internal JavaScript Run-Time Failure
JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</p> <p>12	Invalid Debug Argument
设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。</p> <blockquote><p>128	Signal Exits
如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 输出到终端</span>
process<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 通过参数读取</span>
process<span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token string">': '</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 获取执行路局</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>execPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 平台信息</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="看看这段代码输出什么"><a href="#看看这段代码输出什么" class="header-anchor">#</a> 看看这段代码输出什么</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// this in NodeJS global scope is the current module.exports object, not the global object.</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// {}</span>

module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// { foo:5 }</span>
</code></pre></div><h2 id="node-js-事件循环模型"><a href="#node-js-事件循环模型" class="header-anchor">#</a> node.js 事件循环模型</h2> <h3 id="什么是事件循环"><a href="#什么是事件循环" class="header-anchor">#</a> 什么是事件循环</h3> <p>事件循环使 Node.js 可以通过将操作转移到系统内核中来执行非阻塞 I/O 操作（尽管 JavaScript 是单线程的）。</p> <p>由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。 当这些操作之一完成时，内核会告诉 Node.js，以便可以将适当的回调添加到轮询队列中以最终执行。</p> <p>Node.js 启动时，它将初始化事件循环，处理提供的输入脚本，这些脚本可能会进行异步 API 调用，调度计时器或调用 process.nextTick， 然后开始处理事件循环。</p> <div class="language- extra-class"><pre class="language-text"><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre></div><p>每个阶段都有一个要执行的回调 FIFO 队列。 尽管每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行回调的最大数量为止。 当队列已为空或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p> <h3 id="各阶段概览"><a href="#各阶段概览" class="header-anchor">#</a> 各阶段概览</h3> <ol><li>timers：此阶段执行由 setTimeout 和 setInterval 设置的回调。</li> <li>pending callbacks：执行推迟到下一个循环迭代的 I/O 回调。</li> <li>idle, prepare, ：仅在内部使用。</li> <li>poll：取出新完成的 I/O 事件；执行与 I/O 相关的回调（除了关闭回调，计时器调度的回调和 setImmediate 之外，几乎所有这些回调） 适当时，node 将在此处阻塞。</li> <li>check：在这里调用 setImmediate 回调。</li> <li>close callbacks：一些关闭回调，例如 socket.on('close', ...)。</li></ol> <p>在每次事件循环运行之间，Node.js 会检查它是否正在等待任何异步 I/O 或 timers，如果没有，则将其干净地关闭。</p> <h3 id="各阶段详细解析"><a href="#各阶段详细解析" class="header-anchor">#</a> 各阶段详细解析</h3> <h3 id="timers-计时器阶段"><a href="#timers-计时器阶段" class="header-anchor">#</a> timers 计时器阶段</h3> <p>计时器可以在回调后面指定时间阈值，但这不是我们希望其执行的确切时间。 计时器回调将在经过指定的时间后尽早运行。 但是，操作系统调度或其他回调的运行可能会延迟它们。-- 执行的实际时间不确定</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Assume this takes 95ms to complete</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path/to/file'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> timeoutScheduled <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> delay <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeoutScheduled<span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>delay<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms have passed since I was scheduled</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// do someAsyncOperation which takes 95 ms to complete</span>
<span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> startCallback <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// do something that will take 10ms...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startCallback <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do nothing</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当事件循环进入 poll 阶段时，它有一个空队列（fs.readFile 尚未完成），因此它将等待直到达到最快的计时器 timer 阈值为止。
等待 95 ms 过去时，fs.readFile 完成读取文件，并将需要 10ms 完成的其回调添加到轮询 (poll) 队列并执行。
回调完成后，队列中不再有回调，此时事件循环已达到最早计时器 (timer) 的阈值 (100ms)，然后返回到计时器 (timer) 阶段以执行计时器的回调。
在此示例中，您将看到计划的计时器与执行的回调之间的总延迟为 105ms。</p> <h3 id="pending-callbacks-阶段"><a href="#pending-callbacks-阶段" class="header-anchor">#</a> pending callbacks 阶段</h3> <p>此阶段执行某些系统操作的回调，例如 TCP 错误。 平时无需关注</p> <h3 id="轮询-poll-阶段"><a href="#轮询-poll-阶段" class="header-anchor">#</a> 轮询 poll 阶段</h3> <p>轮询阶段具有两个主要功能：</p> <ol><li>计算应该阻塞并 I/O 轮询的时间</li> <li>处理轮询队列 (poll queue) 中的事件</li></ol> <p>当事件循环进入轮询 (poll) 阶段并且没有任何计时器调度 (timers scheduled) 时，将发生以下两种情况之一：</p> <ol><li>如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，直到队列用尽或达到与系统相关的硬限制为止 (到底是哪些硬限制？)。</li> <li>如果轮询队列为空，则会发生以下两种情况之一：
2.1 如果已通过 setImmediate 调度了脚本，则事件循环将结束轮询 poll 阶段，并继续执行 check 阶段以执行那些调度的脚本。
2.2 如果脚本并没有 setImmediate 设置回调，则事件循环将等待 poll 队列中的回调，然后立即执行它们。</li></ol> <p>一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 timer 已经到时间。 如果一个或多个计时器 timer 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调。</p> <h3 id="检查阶段-check"><a href="#检查阶段-check" class="header-anchor">#</a> 检查阶段 check</h3> <p>此阶段允许在轮询 poll 阶段完成后立即执行回调。 如果轮询 poll 阶段处于空闲，并且脚本已使用 setImmediate 进入 check 队列，则事件循环可能会进入 check 阶段，而不是在 poll 阶段等待。</p> <p>setImmediate 实际上是一个特殊的计时器，它在事件循环的单独阶段运行。 它使用 libuv API，该 API 计划在轮询阶段完成后执行回调。</p> <p>通常，在执行代码时，事件循环最终将到达轮询 poll 阶段，在该阶段它将等待传入的连接，请求等。但是，如果已使用 setImmediate 设置回调并且轮询阶段变为空闲，则它将将结束并进入 check 阶段，而不是等待轮询事件。</p> <h3 id="close-callbacks-阶段"><a href="#close-callbacks-阶段" class="header-anchor">#</a> close callbacks 阶段</h3> <p>如果套接字或句柄突然关闭（例如 socket.destroy），则在此阶段将发出 'close' 事件。 否则它将通过 process.nextTick 发出。</p> <h3 id="setimmediate-和-settimeout-的区别"><a href="#setimmediate-和-settimeout-的区别" class="header-anchor">#</a> setImmediate 和 setTimeout 的区别</h3> <p>setImmediate 和 setTimeout 相似，但是根据调用时间的不同，它们的行为也不同。</p> <ul><li>setImmediate 设计为在当前轮询 poll 阶段完成后执行脚本。</li> <li>setTimeout 计划在以毫秒为单位的最小阈值过去之后运行脚本。</li></ul> <p>Tips: 计时器的执行顺序将根据调用它们的上下文而有所不同。 如果两者都是主模块中调用的，则时序将受到进程性能的限制.</p> <p>来看两个例子：</p> <ol><li><p>在主模块中执行</p> <p>两者的执行顺序是不固定的, 可能timeout在前, 也可能immediate在前</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>在同一个I/O回调里执行</p> <p>setImmediate总是先执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <p>问题：那为什么在外部 (比如主代码部分 mainline) 这两者的执行顺序不确定呢？</p> <p>解答：在 主代码 部分执行 setTimeout 设置定时器 (此时还没有写入队列)，与 setImmediate 写入 check 队列。</p> <p>mainline 执行完开始事件循环，第一阶段是 timers，这时候 timers 队列可能为空，也可能有回调；
如果没有那么执行 check 队列的回调，下一轮循环在检查并执行 timers 队列的回调；
如果有就先执行 timers 的回调，再执行 check 阶段的回调。因此这是 timers 的不确定性导致的。</p> <h3 id="process-nexttick"><a href="#process-nexttick" class="header-anchor">#</a> process.nextTick</h3> <p>process.nextTick 从技术上讲不是事件循环的一部分。 相反，无论事件循环的当前阶段如何，都将在当前操作完成之后处理 nextTickQueue</p> <h3 id="process-nexttick-和-setimmediate-的区别"><a href="#process-nexttick-和-setimmediate-的区别" class="header-anchor">#</a> process.nextTick 和 setImmediate 的区别</h3> <ul><li>process.nextTick 在同一阶段立即触发</li> <li>setImmediate fires on the following iteration or 'tick' of the event loop (在事件循环接下来的阶段迭代中执行 - check 阶段)。</li></ul> <h3 id="nexttick在事件循环中的位置"><a href="#nexttick在事件循环中的位置" class="header-anchor">#</a> nextTick在事件循环中的位置</h3> <div class="language- extra-class"><pre class="language-text"><code>           ┌───────────────────────────┐
        ┌─&gt;│           timers          │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │     pending callbacks     │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        |  |     idle, prepare         │
        |  └─────────────┬─────────────┘
  nextTickQueue     nextTickQueue
        |  ┌─────────────┴─────────────┐
        |  │           poll            │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │           check           │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        └──┤       close callbacks     │
           └───────────────────────────┘
</code></pre></div><h3 id="microtasks-微任务"><a href="#microtasks-微任务" class="header-anchor">#</a> Microtasks 微任务</h3> <p>在 Node 领域，微任务是来自以下对象的回调：</p> <ol><li>process.nextTick()</li> <li>then()</li></ol> <p>在主线结束后以及事件循环的每个阶段之后，立即运行微任务回调。</p> <p>resolved 的 promise.then 回调像微处理一样执行，就像 process.nextTick 一样。 虽然，如果两者都在同一个微任务队列中，则将首先执行 process.nextTick 的回调。</p> <p>优先级 process.nextTick &gt; promise.then</p> <h3 id="看代码输出顺序"><a href="#看代码输出顺序" class="header-anchor">#</a> 看代码输出顺序</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout0'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise3'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myBlog/web/this.html" class="prev">
        this
      </a></span> <span class="next"><a href="/myBlog/web/网络.html">
        网络
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.135fd291.js" defer></script><script src="/myBlog/assets/js/2.2b6e9a37.js" defer></script><script src="/myBlog/assets/js/20.a06b9bd2.js" defer></script>
  </body>
</html>
